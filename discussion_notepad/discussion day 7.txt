
Day 7:
-----------

* introduction to java threads
* creating and running the threads
* thread life cycle basics
* synchronization 
* producer consumer problem
* volitle keywords
* dead lock
* problem with java threads api
* introduction to juc
* threads safe data structure
* introduction to thread pools
* difference kind of threads pools cpu vs io bound process



Hello world thread program:
=========================


//worker and job
-------------------------

//Thread is used to create the work
---------
//Runnale is used to creating job 
---------

//creating worker assign job to the worker
//threads methods: sleep, join etc

//create a job
class MyJob implements Runnable{

	@Override
	public void run() {
		System.out.println("thread is started : "+Thread.currentThread().getName() );
		try{
			Thread.sleep(1000);
		}catch(InterruptedException ex){
			ex.printStackTrace();
		}
		
		System.out.println("thread is finished : "+Thread.currentThread().getName() );
	}
	
}
public class A_DemoThread1_Using_Runnable {
	
	public static void main(String[] args) {

		System.out.println("i am in main threads: "+Thread.currentThread().getName());
		
		MyJob job=new MyJob();
		
		Thread thread=new Thread(job,"A");
		
		//thread.setPriority(Thread.MAX_PRIORITY-2);
		thread.start();
		
		
		System.out.println("main threads is finished: "+Thread.currentThread().getName());
	}

}


Note: never call run() method directly u should always call start() method and run is called by
thread scheudle (part of OS)

Threads to create the threads
threads===OS level threads


life cycle of threads
------------------------


							Block
							
							
new ---> runnable -----------------> running --------------------> dead


Note: threads are resouce hungry (CPU cycle)


Now we are starting 3 threads:
--------------------------
A B C

it is not gurentted the order of ex of threads


i am in main threads: main
main threads is finished: main
thread is started : B
thread is started : A
thread is started : C
thread is finished : C
thread is finished : B
thread is finished : A



i am in main threads: main
main threads is finished: main
thread is started : A
thread is started : B
thread is started : C
thread is finished : B
thread is finished : C
thread is finished : A



how to control it?


class MyJob implements Runnable{

	@Override
	public void run() {
		System.out.println("thread is started : "+Thread.currentThread().getName() );
		try{
			Thread.sleep(1000);
		}catch(InterruptedException ex){
			ex.printStackTrace();
		}
		
		System.out.println("thread is finished : "+Thread.currentThread().getName() );
	}
	
}
public class A_DemoThread1_Using_Runnable {
	
	public static void main(String[] args) {

		System.out.println("i am in main threads: "+Thread.currentThread().getName());
		
		MyJob job=new MyJob();
		
		Thread thread=new Thread(job,"A");
		Thread thread2=new Thread(job,"B");
		Thread thread3=new Thread(job,"C");
		
		//thread.setPriority(Thread.MAX_PRIORITY-2);
		thread.start();
		thread2.start();
		thread3.start();//order of calling start method dont matter, it depend on thread scheudler
		//not on programmer 
		
		
		System.out.println("main threads is finished: "+Thread.currentThread().getName());
	}

}




//how to ensure that main should finished at end?
=======================================================
//method called join() method can be used to achive that
		
		
		

//how to ensure that main should finished at end?
		//method called join() method can be used to achive that
		
		try{
			
			thread.join();//ie thread is saying to main thread join after me
			thread2.join();
			thread3.join(2000);//ie hey thread main only wait for my compition for just 2sec
			//otherwise u can finished
			
		}catch(InterruptedException ex){
			ex.printStackTrace();
		}
		
		
		

i am in main threads: main
thread is started : A
thread is started : B
thread is started : C
thread is finished : A
thread is finished : B
thread is finished : C
main threads is finished: main




Creating thread by extending Thread class
------------------------------------------

//problem u can not extend more then one class in java
//this way of creating thread is not very common

class MyThread extends Thread{
	 public MyThread(String name) {
		super(name);
	}
	@Override
	public void run(){
		System.out.println("thread is started : "+Thread.currentThread().getName() );
		try{
			Thread.sleep(1000);
		}catch(InterruptedException ex){
			ex.printStackTrace();
		}
		
		System.out.println("thread is finished : "+Thread.currentThread().getName() );
	}
}
public class B_DemoThread1_Using_Thread {

	public static void main(String[] args) {
	
		
		MyThread t1=new MyThread("foo");
		t1.start();
	}
}





Creating thread by using ann inner class
------------------------------------------

public class C_DemoThread1_Using_AnnInnerClass {

	public static void main(String[] args) {

		Runnable runnable=new Runnable() {
			
			@Override
			public void run() {
				System.out.println("thread is started : "+Thread.currentThread().getName() );
			}
		};
		
		Thread thread=new Thread(runnable,"A");
		thread.start();
		
	}
}




Creating thread by using lambda expression
------------------------------------------
	Runnable runnable=()-> 
				System.out.println("thread is started : "+Thread.currentThread().getName() );
			
		
		
		Thread thread=new Thread(runnable,"A");
		thread.start();
		
		//or
		
		Thread thread=new Thread(()-> 
		System.out.println("thread is started : "+Thread.currentThread().getName() ),"A");
		thread.start();
		


Need of synchronization in java
===============================


//consider 1 Printer --and -> Client1, 2 , 3

//we can have race condition



class Printer {
	public void print(String letter){
		
		//Critical section / CR
		System.out.print("[");
		
		try{
			Thread.sleep(1000);
		}catch(InterruptedException e){
			e.printStackTrace();
		}
		System.out.println( letter +"]");
	}
}

class Client extends Thread{
	
	private Printer printer;
	private String letter;
	
	public Client(Printer printer, String letter) {
		this.printer = printer;
		this.letter = letter;
		this.start();
	}

	public void run(){
		printer.print(letter);
	}
}

public class A_NeedOfSynchronized {
	public static void main(String[] args) {
		
		//1 printer shared bw 3 clients
		Printer printer=new Printer();
		Client c1=new Client(printer, "i love java");
		Client c2=new Client(printer, "i hate java");
		Client c3=new Client(printer, "i am joining another project");
		
		
		
	}

}


sol: use synchronized kb

how it synchronized works?
===========================

washroom analogy




synchronized block vs synchronized method
==============================================
class Printer {
	public synchronized void print(String letter){
		
		
		///
		//synchronized block vs synchronized method
		//synchronized block is better then synchronized method : performance
		
		//this refer to the current object Printer object act as a lock
		synchronized (this) {
			System.out.print("[");
			try{
				Thread.sleep(1000);
			}catch(InterruptedException e){
				e.printStackTrace();
			}
			System.out.println( letter +"]");
		}
		
		//
		//
	}
}





//this refer to the current object Printer object act as a lock

Q: can any object in java act as a lock
YES

class Printer {
	//any object in java can act as a lock
	private Object lock=new Object();
	
	public void print(String letter){
	
		///
		//synchronized block vs synchronized method
		//synchronized block is better then synchronized method : performance
		
		//this refer to the current object Printer object act as a lock
		synchronized (lock) {
			System.out.print("[");
			try{
				Thread.sleep(1000);
			}catch(InterruptedException e){
				e.printStackTrace();
			}
			System.out.println( letter +"]");
		}
		//
		//
	}
}


t1.yield();
----------------
is just a polite req from thread t1 to realease the cpu cycle..but it can be ignore by thread scheduler


thread priority : thread scheduler can ignore it


//What is volatile key word does?
=====================================
volatile vs synchronized


class Test extends Thread {

   volatile boolean keepRunning = true;

    public void run() {
        while (keepRunning) {
        }
        System.out.println("Thread terminated.");
    }

    public static void main(String[] args) throws InterruptedException {
        Test t = new Test();
        t.start();
        Thread.sleep(1000);
        t.keepRunning = false;
        System.out.println("keepRunning set to false.");
    }
}

How volatile work?
===================


program dont behave as expected :
-----------------------------------
class Test extends Thread {

    boolean keepRunning = true;

    public void run() {
        while (keepRunning) {
        }
        System.out.println("Thread terminated.");
    }

    public static void main(String[] args) throws InterruptedException {
        Test t = new Test();
        t.start();
        Thread.sleep(1000);
        t.keepRunning = false;
        System.out.println("keepRunning set to false.");
    }
}


program  behave as expected :
-----------------------------------

class Test extends Thread {

   volatile boolean keepRunning = true;

    public void run() {
    	
        while (keepRunning) {
        }
        
        System.out.println("Thread terminated.");
    }

    public static void main(String[] args) throws InterruptedException {
    	//2 threads : main and other is t
    	
        Test t = new Test();
        t.start();
        Thread.sleep(1000);
        t.keepRunning = false;
        System.out.println("keepRunning set to false.");
    }
}


volatile vs synchronized
=========================
which is better in performance: volatile kb
there are some use case for volitile

volatile kb is introduced in java 1.4
but it is not working correctly till java 1.5


volatile: visiblity problem

synchronized: thread safty as well as visiblity problem


