
Discussion day 3:
====================

class A{
	void A(){
		Sytem.out.println("hello");
	}
	public void doWork(){
	Sytem.out.println("doing work");
	}
}

class Demo{
	public static void main(String args[]){
			A a=new A();
			a.doWork();
			
	}

}




class A {

	A(int a) {
		System.out.println("hello ctr A");
	}
}

class B extends A {
	B() {
		System.out.println("hello ctr B");
	}
}

public class Demo {
	public static void main(String args[]) {
		B b = new B();

	}

}


class A {

	A(int a) {
		System.out.println("hello ctr A "+ a);
	}
}

class B extends A {
	B(int a, int b) {
		super(a);
		System.out.println("hello ctr B "+b);
	}
}

public class Demo {
	public static void main(String args[]) {
		
		B b = new B(3,5);

	}

}




class A {
  static public void doWork(){
	System.out.println("doing work 1");
	}
	
}

class B extends A {
	static public void doWork(){
		System.out.println("doing work 2");
	}
}

public class Demo {
	public static void main(String args[]) {
		
		A a=new B();
		a.doWork();

	}
}




-----------------------------






* Quick recap of day 2
* Java interface , abstract class
* when to use interface and when to use abstract class
* interface break the hierarchy

* String class in java
*String vs StringBuilder vs StringBuffer
*string is special class, string pool, performance

* immutablity
* how to create immutable class (object)?

* inner classes: introduction
* annonymous inner class vs lambda

* java 5 features



Quick recap on abstract class:
------------------------------------

/*
 * features of ab class
 * it can have instane varaible, static/method . ctr....
 * only limiation is that u can not create object of it
 * 
 * and if a class have ab method then it must be declare abstract
 * 
 */



What is interface ?
--------------------------------

act as a contract bw 2 parties , it is 100% abstraction in java

in order to achive abstraction you have 2 techeniques:
1. java interface
2. abstract class

basic synte, why to use it

java 8 there are some changes in the inteface...

	
	
	
	
Ex interface:
---------------
//java 7 : it is 100% abstraction in java
//i can not define an instance variable inside interface,
//u  can only define static and final data only class vairable is alled

interface Foo{
	 int i=5;//public static final
	 void foo();// it is by default public abstract
}
//u want to create a class
class MyFooImpl implements Foo{

	@Override
	public void foo() {
		System.out.println(Foo.i);
		System.out.println("foo method is overriden by MyFooImpl class");
	}
	
}
public class A_InterfaceBasics {
	
	public static void main(String[] args) {
		Foo f=new MyFooImpl();
		f.foo();
	}

}



//a class can imp more then 1 interface (it is not possible class)
===================================================================

interface Foo{
	 int i=5;//public static final
	 void foo();// it is by default public abstract
}

interface Bar{
	 int j=5;//public static final
	 void foo2();// it is by default public abstract
}

//u want to create a class
class MyFooImpl implements Foo,Bar{

	@Override
	public void foo() {
		System.out.println(Foo.i);
		System.out.println("foo method is overriden by MyFooImpl class");
	}

	@Override
	public void foo2() {
		System.out.println(Bar.j);
		System.out.println("foo2() method is overriden by MyFooImpl class");
	}
	
}
public class A_InterfaceBasics {
	
	public static void main(String[] args) {
		Foo f=new MyFooImpl();
		f.foo();
	}

}



Note: some improvement in java 8 regarding interfaces:
================================================

	1. //now u an have default imp of the method , why
	2. //now u can also add static method inside the interface

//now some imp is done inside interface concept
interface Z{
	int i=0;
	public void fooZ();
	
	//now u an have default imp of the method , why
	default public void fooDefault(){
		System.out.println("fooDefault method inside Z interface");
	}
	//now u can also add static method inside the interface
	public static void fooStatic(){
		System.out.println("fooStatic");
	}
}
class ZImpl implements Z{

	@Override
	public void fooZ() {
		System.out.println("fooZ method is overriden");
	}
	
}
public class A1_InterfaceImpInJava8 {
	
	public static void main(String[] args) {
		Z z=new ZImpl();
		z.fooZ();
		Z.fooStatic();
	}

}



When to go for interface and when to go for abs class:
--------------------------------------------------------

interface Jumpable{
	public void jump();
}
class Monkey implements Jumpable{
	public void stayOnTree(){
		System.out.println("stayOnTree...");
	}
	
	public void jump(){
		System.out.println("monkey jump like anything...");
	}
}
//Kid is not monkey but he can jump like monkey
class Kid implements Jumpable{
	
	public void goSchool(){
		System.out.println("doing to school");
	}
	
	public void study(){
		System.out.println("study");
	}
	
	public void jump(){
		System.out.println("kid jump better then anything...");
	}
}

public class C_WhenToGoForInterfaceVsAbstractClass {
	
	public static void main(String[] args) {
		Kid k=new Kid();
		
	}

}

Assignment : salary procesing system:
--------------------------------------

abstract public class Employee {
	private int id;
	private String name;
	private double salary;
	
	
	public abstract double getPay();
	
	public Employee(int id, String name, double salary) {
		this.id = id;
		this.name = name;
		this.salary = salary;
	}
	
	public void printEmployee(){
		System.out.println("id : "+ id);
		System.out.println("name: "+ name);
		System.out.println("salary: "+ salary);
	}
	
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}

	public double getSalary() {
		return salary;
	}

	public void setSalary(double salary) {
		this.salary = salary;
	}
	
	
}



public class FullTimeEmployee extends Employee{

	private String ppf;
	
	public  FullTimeEmployee(int id, String name, double salary, String ppf) {
		super(id, name, salary);
		this.ppf=ppf;
	}
	
	@Override
	public double getPay() {
		return getSalary()*0.7;
	}

	public void printEmployee(){
		super.printEmployee();
		System.out.println("ppf : "+ ppf);
	}
	
}







public class PartTimeEmployee extends Employee{

	private int noOfDays;
	private int noOfHr;
	private int ratePerHr;
	
	public  PartTimeEmployee(int id, String name, double salary, int noOfDays, int noOfHr ,
			int ratePerHr) {
		super(id, name, salary);
		this.noOfDays=noOfDays;
		this.noOfHr=noOfHr;
		this.ratePerHr=ratePerHr;
	}
	
	@Override
	public double getPay() {
		//1000+20*5*2000
		return (getSalary()+noOfDays*noOfHr*ratePerHr) *.8;
	}

	public void printEmployee(){
		super.printEmployee();
		System.out.println("noOfDays : "+ noOfDays);
		System.out.println("noOfHr : "+ noOfHr);
		System.out.println("ratePerHr : "+ ratePerHr);
		
	}
	
}




public class Main {
	
	public static void main(String[] args) {
		
		Employee e=new PartTimeEmployee(1, "rajat", 1200, 12,5,2500);
		e.printEmployee();
		System.out.println(e.getPay());
		
//		Employee e=new FullTimeEmployee(1, "rajat", 120000, "ASJLKJLJ");
//		e.printEmployee();
//		System.out.println(e.getPay());
	}

}


We have to implements payment procesing system:

public class PaymentProcessor {
	
	public static void paymentProcessing(Employee employee){
		double payment= employee.getPay();
		//some jdbc ( data connectivity) to put data to database
		System.out.println("---------------------------");
		System.out.println("payment is being process "+ payment);
		System.out.println("---------------------------");
		
	}

}



but problem :(

it is tigtly coupled with employeee
i do have new req to process the payment of consultants?



inteface can help you:
------------------------



String :
* very imp and used class in java
* it is final class
class MyClass extends String{
}

	ERROR
	
* String objects are immutable ie they can not be changes once they are created
* bad code 
String data="a"+"b"+"c"+"d";
why?
as lots of unnessary objects are created in the string pool
	performance problem
	performance tuning is a subject
	
	
Q:
---
What is the ans to the Questions?
----------------------------
    
    	String name1=new String("raj");
    	
    	String name2="raj";
    	
    	System.out.println(name1==name2);// compare the address
    	
		
	=> false
	
	
What is the ans to the Questions?
----------------------------
    	String name1="raj";
    	
    	String name2="raj";
    	
    	System.out.println(name1==name2);// compare the address

	=> true
	
	
	
	
String 	vs StringBuilder vs StringBuffer: imp
=================================================
	
	
    	//String 	vs StringBuilder vs StringBuffer: imp
    	//Immutable	---mutable
    	//StringBuilder : is not thread safe , very good in performance , no locking is used 
    	//java 1.5
    	
    	//vs 
    	//StringBuffer: is thread safe , but poor in performance
    	
    	
//    	
//    	StringBuilder sb=
//    			new StringBuilder().append("a").append("b").append("c");
    	
    	