
Discussion day 2:
====================

//java oo basics: class , object , ctr: default parameteriszed, copy ctr
	//gettter setters
	//business logic methods
	//this keyword
	
	
	
step 1: create a class 
-----------------

class Employee{
	private int id;
	private String name;
	private double salary;
	
	public Employee(){
		System.out.println("it is a default ctr");
	}
	//what is the job of ctr? used to init initial values to instance variable
	public Employee(int myId, String myName, double mySalary){
		id=myId;
		name=myName;
		salary=mySalary;
	}
	
	public void printEmployee(){
		System.out.println("id : "+ id );
		System.out.println("name : "+ name );
		System.out.println("salary : "+ salary );
	}
}

	
//step 1: create a class to test the code
//-----------------

public class A_BasicsOfJavaClass {
	
	//java oo basics: class , object , ctr: default parameteriszed, copy ctr
	//gettter setters
	//business logic methods
	//this keyword
	public static void main(String[] args) {
		
		Employee e1=new Employee(2,"raj",67000);
		e1.printEmployee();
		
	}

}


---------------------------------------------

Demo: ctr, getter setter , coding convesion, this, autogen of method by ide

---------------------------------------------
class Employee{
	private int id;
	private String name;
	private double salary;
	
	//getter and setter (mutator?)
	
	public void setSalary(int salary){
		this.salary=salary;
	}
	
	public int getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public double getSalary() {
		return salary;
	}

	//default ctr
	public Employee(){
		this(1,"foo",90000);
		System.out.println("this is default ctr");
	}
	//para ... ctr
	//what is the job of ctr? used to init initial values to instance variable
	public Employee(int id, String name, double salary){
		//this();
		this.id=id;
		this.name=name;
		this.salary=salary;
	}
	
	//copy ctr: used to create the object with the help of state of another object
	public Employee(Employee e){
		this.id=e.id;
		this.name=e.name;
		this.salary=e.salary;
	}
	
	
	public void printEmployee(){
		System.out.println("id : "+ id );
		System.out.println("name : "+ name );
		System.out.println("salary : "+ salary );
	}
}
public class A_BasicsOfJavaClass {
	
	//java oo basics: class , object , ctr: default parameteriszed, copy ctr
	//gettter setters
	//business logic methods
	//this keyword
	public static void main(String[] args) {
		
		Employee e1=new Employee(2,"raj",67000);
		e1.printEmployee();
		
		e1.setSalary(100_000);
		
		e1.printEmployee();
		
		System.out.println(e1.getSalary());
		System.out.println(e1.getName());
		System.out.println(e1.getId());
		
		
	}

}

-------------------------------------------------------

coding convesion:
===========================
	* name of class must start with capital
	
	class Employee{
	
	
	}
	
	class FullTimeEmployee{
	
	
	}
	
	* convesion about data : instance/static/ local /final
	
	
	class Employee{
			private int employeeId;
			
			private String employeeName;
			
			private double employeeSalary;
			
			private static String companyName="XYZ";
			
			public final double INCREMENT_FACTOR=1.01;
			
			public void applyIncrementToTheEmployeeSalary(){
			
			
			}
	
	
	}
	
===================================================

What is the need of init block

consider:

-------------

//what is init block means initilization block
//DRY :dont repeat yourself?

class Foo{
	public Foo(){
		System.out.println("some code line 1");
		System.out.println("some code line 2");
		
		System.out.println("code for default ctr");
	}
	
	public Foo(int x){
		System.out.println("some code line 1");
		System.out.println("some code line 2");
		
		System.out.println("code for parameterized ctr");
	}
}
public class B_InitBlock {
	
	public static void main(String[] args) {
		
	}

}



hope u can find the repeated code:
sound bad:
----------------------------------
class Foo{
	//init block: common code for every ctr
	{
		System.out.println("some code line 1");
		System.out.println("some code line 2");
	}
	
	public Foo(){
		System.out.println("code for default ctr");
	}
	
	public Foo(int x){
		
		System.out.println("code for parameterized ctr");
	}
}

----------------------------------------------
what about something called static init block?
---------------------------------------------

class Foo{
	//init block: common code for every ctr
	private static double value;
	
	static{
		System.out.println("it is a static init block");
		//static init block called only once at the class loading time
		value=Math.PI*1;
	}
	
	{
		System.out.println("some code line 1");
		System.out.println("some code line 2");
	}
	
	public Foo(){
		System.out.println("code for default ctr");
	}
	
	public Foo(int x){
		
		System.out.println("code for parameterized ctr");
	}
}
------------------------------'
can i have more then one init block: YES!
-------------------------------------------

//java support only call by value not call by reference



u cant swap values like this : c/c++/java
============================================

public class A_CallByValue {
	
	public static void main(String[] args) {
		int i=1;
		int j=2;
		System.out.println("value of i: "+ i +" value of j: "+ j);
		swap(i, j);
		System.out.println("value of i: "+ i +" value of j: "+ j);
	}

	private static void swap(int i, int j) {
		int temp=i;
		i=j;
		j=temp;
	}
}

Java dont provide u pointer (internally it have it)
====================================================
class Value{
	private int v;

	public Value(int v){
		this.v=v;
	}
	public int getV() {
		return v;
	}

	public void setV(int v) {
		this.v = v;
	}
	
}

public class B_CallByValueEx2 {
	
	public static void main(String[] args) {
		Value v1=new Value(1);
		Value v2=new Value(2);
		
		System.out.println("value of v1: "+ v1.getV() +" value of v2: "+ v2.getV());
		swap(v1, v2);
		System.out.println("value of v1: "+ v1.getV() +" value of v2: "+ v2.getV());
	}

	private static void swap(Value i, Value j) {
		Value temp=i;
		i=j;
		j=temp;
	}
}


--------------------------------------------------------
Swapping of object even doent work!
-------------------------------------------------------

class Value{
	private int v;

	public Value(int v){
		this.v=v;
	}
	public int getV() {
		return v;
	}

	public void setV(int v) {
		this.v = v;
	}
	
}

public class B_CallByValueEx2 {
	
	public static void main(String[] args) {
		Value v1=new Value(1);
		Value v2=new Value(2);
		
		System.out.println("value of v1: "+ v1.getV() +" value of v2: "+ v2.getV());
		swap(v1, v2);
		System.out.println("value of v1: "+ v1.getV() +" value of v2: "+ v2.getV());
	}

	private static void swap(Value i, Value j) {
		Value temp=i;
		i=j;
		j=temp;
	}
}
-----------------------------------
public class CopyOfB_CallByValueEx3 {
	
	public static void main(String[] args) {
		Value value=new Value(5);
		//java says u cant swap 2 objects in java (trick: of array)
		//but u can change the state of object in a method call?
		System.out.println("value is : "+ value.getV());
		changeIt(value);
		System.out.println("value is : "+ value.getV());
	}

	private static void changeIt(Value x) {
		x.setV(x.getV()*2);
	}

}
------------------------------------------------------

What is the effect of final in method arguments?
--------------------------------------------------

public class CopyOfB_CallByValueEx3 {
	
	public static void main(String[] args) {
		Value value=new Value(5);
		//java says u cant swap 2 objects in java (trick: of array)
		//but u can change the state of object in a method call?
		System.out.println("value is : "+ value.getV());
		changeIt(value);
		System.out.println("value is : "+ value.getV());//NPE?
	}

	private static void changeIt(final Value x) {
//		x=new Value(100);// u are not allowed the change the ref
		x.setV(x.getV()*2);//but u are allowed to change the state of obj
		//that is pointed by the pointer (ref)
	}
}
